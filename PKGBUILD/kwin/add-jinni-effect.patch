From 7630297e290e932e920db34a42cfa778db422e94 Mon Sep 17 00:00:00 2001
From: Vlad Zagorodniy <vladzzag@gmail.com>
Date: Fri, 12 Jan 2018 22:53:33 +0200
Subject: [PATCH] add jinni effect

---
 effects/CMakeLists.txt             |   3 +
 effects/effect_builtins.cpp        |  16 ++
 effects/jinni/CMakeLists.txt       |  24 +++
 effects/jinni/jinni.cpp            | 428 +++++++++++++++++++++++++++++++++++++
 effects/jinni/jinni.h              |  66 ++++++
 effects/jinni/jinni.kcfg           |  22 ++
 effects/jinni/jinni_config.cpp     |  44 ++++
 effects/jinni/jinni_config.desktop |   8 +
 effects/jinni/jinni_config.h       |  26 +++
 effects/jinni/jinni_config.ui      | 139 ++++++++++++
 effects/jinni/jinniconfig.kcfgc    |   5 +
 effects/jinni/timeline.h           | 118 ++++++++++
 12 files changed, 899 insertions(+)
 create mode 100644 effects/jinni/CMakeLists.txt
 create mode 100644 effects/jinni/jinni.cpp
 create mode 100644 effects/jinni/jinni.h
 create mode 100644 effects/jinni/jinni.kcfg
 create mode 100644 effects/jinni/jinni_config.cpp
 create mode 100644 effects/jinni/jinni_config.desktop
 create mode 100644 effects/jinni/jinni_config.h
 create mode 100644 effects/jinni/jinni_config.ui
 create mode 100644 effects/jinni/jinniconfig.kcfgc
 create mode 100644 effects/jinni/timeline.h

diff --git a/effects/CMakeLists.txt b/effects/CMakeLists.txt
index 30b731352..498c2967b 100644
--- a/effects/CMakeLists.txt
+++ b/effects/CMakeLists.txt
@@ -82,6 +82,7 @@ set( kwin4_effect_builtins_sources
     flipswitch/flipswitch.cpp
     glide/glide.cpp
     invert/invert.cpp
+    jinni/jinni.cpp
     lookingglass/lookingglass.cpp
     magiclamp/magiclamp.cpp
     magnifier/magnifier.cpp
@@ -112,6 +113,7 @@ kconfig_add_kcfg_files(kwin4_effect_builtins_sources
     fallapart/fallapartconfig.kcfgc
     flipswitch/flipswitchconfig.kcfgc
     glide/glideconfig.kcfgc
+    jinni/jinniconfig.kcfgc
     lookingglass/lookingglassconfig.kcfgc
     magiclamp/magiclampconfig.kcfgc
     magnifier/magnifierconfig.kcfgc
@@ -152,6 +154,7 @@ add_subdirectory( diminactive )
 include( dimscreen/CMakeLists.txt )
 include( fallapart/CMakeLists.txt )
 include( highlightwindow/CMakeLists.txt )
+add_subdirectory( jinni )
 include( kscreen/CMakeLists.txt )
 add_subdirectory( magiclamp )
 include( minimizeanimation/CMakeLists.txt )
diff --git a/effects/effect_builtins.cpp b/effects/effect_builtins.cpp
index 7198d6cf0..74c912164 100644
--- a/effects/effect_builtins.cpp
+++ b/effects/effect_builtins.cpp
@@ -34,6 +34,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "dimscreen/dimscreen.h"
 #include "fallapart/fallapart.h"
 #include "highlightwindow/highlightwindow.h"
+#include "jinni/jinni.h"
 #include "magiclamp/magiclamp.h"
 #include "minimizeanimation/minimizeanimation.h"
 #include "resize/resize.h"
@@ -291,6 +292,21 @@ EFFECT_FALLBACK
         nullptr,
         nullptr
 #endif
+EFFECT_FALLBACK
+    }, {
+        QStringLiteral("jinni"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Jinni"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Minimize a window like a boss."),
+        QStringLiteral("Appearance"),
+        QStringLiteral("minimize"),
+        QUrl(),
+        false,
+        false,
+#ifdef EFFECT_BUILTINS
+        &createHelper<JinniEffect>,
+        &JinniEffect::supported,
+        nullptr
+#endif
 EFFECT_FALLBACK
     }, {
         QStringLiteral("invert"),
diff --git a/effects/jinni/CMakeLists.txt b/effects/jinni/CMakeLists.txt
new file mode 100644
index 000000000..ca0fdd674
--- /dev/null
+++ b/effects/jinni/CMakeLists.txt
@@ -0,0 +1,24 @@
+#######################################
+# Config
+set(kwin_jinni_config_SRCS jinni_config.cpp)
+ki18n_wrap_ui(kwin_jinni_config_SRCS jinni_config.ui)
+qt5_add_dbus_interface(kwin_jinni_config_SRCS ${kwin_effects_dbus_xml} kwineffects_interface)
+kconfig_add_kcfg_files(kwin_jinni_config_SRCS jinniconfig.kcfgc)
+
+add_library(kwin_jinni_config MODULE ${kwin_jinni_config_SRCS})
+
+target_link_libraries(kwin_jinni_config
+    Qt5::DBus
+    KF5::ConfigWidgets
+    KF5::I18n
+    KF5::Service
+)
+
+kcoreaddons_desktop_to_json(kwin_jinni_config jinni_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_jinni_config
+    DESTINATION
+        ${PLUGIN_INSTALL_DIR}/kwin/effects/configs
+)
diff --git a/effects/jinni/jinni.cpp b/effects/jinni/jinni.cpp
new file mode 100644
index 000000000..fc83391db
--- /dev/null
+++ b/effects/jinni/jinni.cpp
@@ -0,0 +1,428 @@
+#include "jinni.h"
+// KConfigSkeleton
+#include "jinniconfig.h"
+
+#include <kwinconfig.h>
+#include <math.h>
+
+namespace KWin
+{
+
+enum class IconPosition
+{
+    Unknown,
+    Bottom,
+    Top,
+    Left,
+    Right
+};
+
+IconPosition getIconPosition(const QRect icon)
+{
+    if (!icon.isValid()) {
+        return IconPosition::Unknown;
+    }
+
+    EffectWindow *panel = nullptr;
+    foreach (EffectWindow *w, effects->stackingOrder()) {
+        if (!w->isDock()) {
+            continue;
+        }
+        if (w->geometry().intersects(icon)) {
+            panel = w;
+            break;
+        }
+    }
+
+    if (panel) {
+        QRect panelScreen = effects->clientArea(ScreenArea, panel);
+        if (panel->width() >= panel->height()) {
+            // horizontal panel
+            return (panel->y() == panelScreen.y())
+                       ? IconPosition::Top
+                       : IconPosition::Bottom;
+        }
+        // vertical panel
+        return (panel->x() == panelScreen.x())
+                   ? IconPosition::Left
+                   : IconPosition::Right;
+    }
+
+    return IconPosition::Unknown;
+}
+
+JinniEffect::JinniEffect()
+{
+    initConfig<JinniConfig>();
+    reconfigure(ReconfigureAll);
+    connect(effects, &EffectsHandler::windowDeleted,
+            this, &JinniEffect::windowDeleted);
+    connect(effects, &EffectsHandler::windowMinimized,
+            this, &JinniEffect::windowMinimized);
+    connect(effects, &EffectsHandler::windowUnminimized,
+            this, &JinniEffect::windowUnminimized);
+
+    mShapeCurve.setType(QEasingCurve::BezierSpline);
+    const QPointF c1(0.55, 0.0);
+    const QPointF c2(0.55, 1.0);
+    const QPointF end(1.0, 1.0);
+    mShapeCurve.addCubicBezierSegment(c1, c2, end);
+}
+
+bool JinniEffect::supported()
+{
+    return effects->isOpenGLCompositing()
+        && effects->animationsSupported();
+}
+
+void JinniEffect::reconfigure(ReconfigureFlags)
+{
+    JinniConfig::self()->read();
+
+    mDuration = JinniConfig::duration();
+    mShapeTransformTime = JinniConfig::shapeTransformTime();
+    mGridResolution = JinniConfig::gridResolution();
+}
+
+void JinniEffect::prePaintScreen(ScreenPrePaintData &data, int time)
+{
+    if (mAnimations.count() > 0) {
+        auto it = mAnimations.begin();
+        while (it != mAnimations.end()) {
+            auto timeline = it.value();
+            timeline->update(time);
+            ++it;
+        }
+        data.mask |= PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS;
+    }
+    effects->prePaintScreen(data, time);
+}
+
+void JinniEffect::prePaintWindow(EffectWindow *w, WindowPrePaintData &data, int time)
+{
+    if (mAnimations.contains(w)) {
+        const auto position = getIconPosition(w->iconGeometry());
+        if (position == IconPosition::Unknown) {
+            effects->prePaintWindow(w, data, time);
+            return;
+        }
+
+        int xSubdivisions = 0;
+        int ySubdivisions = 0;
+        switch (position) {
+        case IconPosition::Top:
+        case IconPosition::Bottom:
+            xSubdivisions = 2;
+            ySubdivisions = mGridResolution;
+            break;
+        case IconPosition::Left:
+        case IconPosition::Right:
+            xSubdivisions = mGridResolution;
+            ySubdivisions = 2;
+            break;
+        default:
+            break;
+        }
+
+        data.setTransformed();
+        data.quads = data.quads.makeRegularGrid(xSubdivisions, ySubdivisions);
+        w->enablePainting(EffectWindow::PAINT_DISABLED_BY_MINIMIZE);
+    }
+
+    effects->prePaintWindow(w, data, time);
+}
+
+void JinniEffect::minimizeBottom(float progress, QRect geometry,
+                                 QRect icon, WindowPaintData &data)
+{
+    const float distance = icon.y() + icon.height() - geometry.y();
+
+    WindowQuadList newQuads;
+    foreach (WindowQuad q, data.quads) {
+        QRect quadGlobal = QRect(QPoint(q.left(), q.top()),
+                                 QPoint(q.right(), q.bottom()));
+        quadGlobal.translate(geometry.topLeft());
+
+        // Calculate Y coords.
+
+        float farthest = q[1].y(),
+              closest = q[3].y();
+
+        if (progress > mShapeTransformTime) {
+            const float moveProgress =
+                (progress - mShapeTransformTime) / (1 - mShapeTransformTime);
+            farthest += moveProgress * distance;
+            closest += moveProgress * distance;
+        }
+
+        // Calculate X coords.
+        const float weightTop = 1 - (distance - farthest) / distance;
+        float progressTop = mShapeCurve.valueForProgress(weightTop);
+        const float weightBottom = 1 - (distance - closest) / distance;
+        float progressBottom = mShapeCurve.valueForProgress(weightBottom);
+
+        if (progress < mShapeTransformTime) {
+            float shapeProgress = progress / mShapeTransformTime;
+            progressTop *= shapeProgress;
+            progressBottom *= shapeProgress;
+        }
+
+        q[0].setX(q[0].x() + progressTop * ((icon.left() - quadGlobal.left()) + icon.width() * q[0].x() / geometry.width()));
+        q[3].setX(q[3].x() + progressBottom * ((icon.left() - quadGlobal.left()) + icon.width() * q[3].x() / geometry.width()));
+        q[1].setX(q[1].x() + progressTop * ((icon.left() - quadGlobal.right()) + icon.width() * q[1].x() / geometry.width()));
+        q[2].setX(q[2].x() + progressBottom * ((icon.left() - quadGlobal.right()) + icon.width() * q[2].x() / geometry.width()));
+
+        q[0].setY(farthest);
+        q[1].setY(farthest);
+        q[2].setY(closest);
+        q[3].setY(closest);
+
+        newQuads.append(q);
+    }
+    data.quads = newQuads;
+}
+
+void JinniEffect::minimizeTop(float progress, QRect geometry,
+                              QRect icon, WindowPaintData &data)
+{
+    const float distance = geometry.y() + geometry.height() - icon.y();
+
+    WindowQuadList newQuads;
+    foreach (WindowQuad q, data.quads) {
+        QRect quadGlobal = QRect(QPoint(q.left(), q.top()),
+                                 QPoint(q.right(), q.bottom()));
+        quadGlobal.translate(geometry.topLeft());
+
+        // Calculate Y coords.
+
+        float farthest = q[3].y(),
+              closest = q[1].y();
+
+        if (progress > mShapeTransformTime) {
+            const float moveProgress =
+                (progress - mShapeTransformTime) / (1 - mShapeTransformTime);
+            farthest -= moveProgress * distance;
+            closest -= moveProgress * distance;
+        }
+
+        // Calculate X coords.
+        const float weightTop = (distance - closest) / distance;
+        float progressTop = mShapeCurve.valueForProgress(weightTop);
+        const float weightBottom = (distance - farthest) / distance;
+        float progressBottom = mShapeCurve.valueForProgress(weightBottom);
+
+        if (progress < mShapeTransformTime) {
+            float shapeProgress = progress / mShapeTransformTime;
+            progressTop *= shapeProgress;
+            progressBottom *= shapeProgress;
+        }
+
+        q[0].setX(q[0].x() + progressTop * ((icon.left() - quadGlobal.left()) + icon.width() * q[0].x() / geometry.width()));
+        q[3].setX(q[3].x() + progressBottom * ((icon.left() - quadGlobal.left()) + icon.width() * q[3].x() / geometry.width()));
+        q[1].setX(q[1].x() + progressTop * ((icon.left() - quadGlobal.right()) + icon.width() * q[1].x() / geometry.width()));
+        q[2].setX(q[2].x() + progressBottom * ((icon.left() - quadGlobal.right()) + icon.width() * q[2].x() / geometry.width()));
+
+        q[0].setY(closest);
+        q[1].setY(closest);
+        q[2].setY(farthest);
+        q[3].setY(farthest);
+
+        newQuads.append(q);
+    }
+    data.quads = newQuads;
+}
+
+void JinniEffect::minimizeLeft(float progress, QRect geometry,
+                               QRect icon, WindowPaintData &data)
+{
+    const float distance = geometry.x() + geometry.width() - icon.x();
+
+    WindowQuadList newQuads;
+    foreach (WindowQuad q, data.quads) {
+        QRect quadGlobal = QRect(QPoint(q.left(), q.top()),
+                                 QPoint(q.right(), q.bottom()));
+        quadGlobal.translate(geometry.topLeft());
+
+        // Calculate Y coords.
+
+        float farthest = q[1].x(),
+              closest = q[0].x();
+
+        if (progress > mShapeTransformTime) {
+            const float moveProgress =
+                (progress - mShapeTransformTime) / (1 - mShapeTransformTime);
+            farthest -= moveProgress * distance;
+            closest -= moveProgress * distance;
+        }
+
+        // Calculate Y coords.
+        const float weightRight = (distance - farthest) / distance;
+        float progressRight = mShapeCurve.valueForProgress(weightRight);
+        const float weightLeft = (distance - closest) / distance;
+        float progressLeft = mShapeCurve.valueForProgress(weightLeft);
+
+        if (progress < mShapeTransformTime) {
+            float shapeProgress = progress / mShapeTransformTime;
+            progressLeft *= shapeProgress;
+            progressRight *= shapeProgress;
+        }
+
+        q[0].setY(q[0].y() + progressLeft * ((icon.top() - quadGlobal.top()) + icon.height() * q[0].y() / geometry.height()));
+        q[3].setY(q[3].y() + progressLeft * ((icon.top() - quadGlobal.bottom()) + icon.height() * q[3].y() / geometry.height()));
+        q[1].setY(q[1].y() + progressRight * ((icon.top() - quadGlobal.top()) + icon.height() * q[1].y() / geometry.height()));
+        q[2].setY(q[2].y() + progressRight * ((icon.top() - quadGlobal.bottom()) + icon.height() * q[2].y() / geometry.height()));
+
+        q[0].setX(closest);
+        q[1].setX(farthest);
+        q[2].setX(farthest);
+        q[3].setX(closest);
+
+        newQuads.append(q);
+    }
+    data.quads = newQuads;
+}
+
+void JinniEffect::minimizeRight(float progress, QRect geometry,
+                                QRect icon, WindowPaintData &data)
+{
+    const float distance = icon.x() + icon.width() - geometry.x();
+
+    WindowQuadList newQuads;
+    foreach (WindowQuad q, data.quads) {
+        QRect quadGlobal = QRect(QPoint(q.left(), q.top()),
+                                 QPoint(q.right(), q.bottom()));
+        quadGlobal.translate(geometry.topLeft());
+
+        // Calculate Y coords.
+
+        float farthest = q[0].x(),
+              closest = q[1].x();
+
+        if (progress > mShapeTransformTime) {
+            const float moveProgress =
+                (progress - mShapeTransformTime) / (1 - mShapeTransformTime);
+            farthest += moveProgress * distance;
+            closest += moveProgress * distance;
+        }
+
+        // Calculate Y coords.
+        const float weightLeft = 1 - (distance - farthest) / distance;
+        float progressLeft = mShapeCurve.valueForProgress(weightLeft);
+        const float weightRight = 1 - (distance - closest) / distance;
+        float progressRight = mShapeCurve.valueForProgress(weightRight);
+
+        if (progress < mShapeTransformTime) {
+            float shapeProgress = progress / mShapeTransformTime;
+            progressLeft *= shapeProgress;
+            progressRight *= shapeProgress;
+        }
+
+        q[0].setY(q[0].y() + progressLeft * ((icon.top() - quadGlobal.top()) + icon.height() * q[0].y() / geometry.height()));
+        q[3].setY(q[3].y() + progressLeft * ((icon.top() - quadGlobal.bottom()) + icon.height() * q[3].y() / geometry.height()));
+        q[1].setY(q[1].y() + progressRight * ((icon.top() - quadGlobal.top()) + icon.height() * q[1].y() / geometry.height()));
+        q[2].setY(q[2].y() + progressRight * ((icon.top() - quadGlobal.bottom()) + icon.height() * q[2].y() / geometry.height()));
+
+        q[0].setX(farthest);
+        q[1].setX(closest);
+        q[2].setX(closest);
+        q[3].setX(farthest);
+
+        newQuads.append(q);
+    }
+    data.quads = newQuads;
+}
+
+void JinniEffect::paintWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data)
+{
+    if (mAnimations.contains(w)) {
+        const auto geometry = w->geometry();
+        const auto icon = w->iconGeometry();
+
+        const auto position = getIconPosition(icon);
+        if (position == IconPosition::Unknown) {
+            effects->paintWindow(w, mask, region, data);
+            return;
+        }
+
+        const auto t = mAnimations[w]->progress();
+
+        switch (position) {
+        case IconPosition::Bottom:
+            minimizeBottom(t, geometry, icon, data);
+            break;
+        case IconPosition::Top:
+            minimizeTop(t, geometry, icon, data);
+            break;
+        case IconPosition::Left:
+            minimizeLeft(t, geometry, icon, data);
+            break;
+        case IconPosition::Right:
+            minimizeRight(t, geometry, icon, data);
+            break;
+        default:
+            break;
+        }
+    }
+    effects->paintWindow(w, mask, region, data);
+}
+
+void JinniEffect::postPaintScreen()
+{
+    if (mAnimations.count() > 0)
+    {
+        auto it = mAnimations.begin();
+        while (it != mAnimations.end()) {
+            auto timeline = it.value();
+            if (timeline->done()) {
+                delete timeline;
+                it = mAnimations.erase(it);
+            } else {
+                ++it;
+            }
+        }
+        effects->addRepaintFull();
+    }
+    effects->postPaintScreen();
+}
+
+void JinniEffect::windowDeleted(EffectWindow *w)
+{
+    if (mAnimations.contains(w)) {
+        delete mAnimations.take(w);
+    }
+}
+
+void JinniEffect::windowMinimized(EffectWindow *w)
+{
+    if (effects->activeFullScreenEffect()) {
+        return;
+    }
+
+    if (! mAnimations.contains(w)) {
+        mAnimations[w] = new Timeline(mDuration, Timeline::Forward);
+    } else {
+        mAnimations[w]->toggleDirection();
+    }
+}
+
+void JinniEffect::windowUnminimized(EffectWindow *w)
+{
+    if (effects->activeFullScreenEffect()) {
+        return;
+    }
+
+    if (! mAnimations.contains(w)) {
+        mAnimations[w] = new Timeline(mDuration, Timeline::Backward);
+    } else {
+        mAnimations[w]->toggleDirection();
+    }
+}
+
+bool JinniEffect::isActive() const
+{
+    return !mAnimations.empty();
+}
+
+}
+
+#include "jinni.moc"
diff --git a/effects/jinni/jinni.h b/effects/jinni/jinni.h
new file mode 100644
index 000000000..557b3a69e
--- /dev/null
+++ b/effects/jinni/jinni.h
@@ -0,0 +1,66 @@
+#ifndef KWIN_JINNI_H
+#define KWIN_JINNI_H
+
+#include <kwineffects.h>
+
+#include <QEasingCurve>
+
+#include "timeline.h"
+
+namespace KWin {
+
+class JinniEffect : public Effect {
+    Q_OBJECT
+
+public:
+    JinniEffect();
+
+    void reconfigure(ReconfigureFlags) override;
+
+    void prePaintScreen(ScreenPrePaintData& data, int time) override;
+    void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, int time) override;
+    void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    void postPaintScreen() override;
+
+    bool isActive() const override;
+
+    int requestedEffectChainPosition() const override {
+        return 50;
+    }
+
+    static bool supported();
+
+private Q_SLOTS:
+    void windowDeleted(EffectWindow *w);
+    void windowMinimized(EffectWindow *w);
+    void windowUnminimized(EffectWindow *w);
+
+private:
+    void minimizeBottom(
+      float progress, QRect geometry,
+      QRect icon, WindowPaintData& data);
+
+    void minimizeTop(
+      float progress, QRect geometry,
+      QRect icon, WindowPaintData& data);
+
+    void minimizeLeft(
+      float progress, QRect geometry,
+      QRect icon, WindowPaintData& data);
+
+    void minimizeRight(
+      float progress, QRect geometry,
+      QRect icon, WindowPaintData& data);
+
+private:
+    int mDuration = 600;
+    float mShapeTransformTime = 0.4;
+    QEasingCurve mShapeCurve;
+    int mGridResolution = 100;
+
+    QHash<EffectWindow*, Timeline*> mAnimations;
+};
+
+}
+
+#endif
diff --git a/effects/jinni/jinni.kcfg b/effects/jinni/jinni.kcfg
new file mode 100644
index 000000000..6a438b6d9
--- /dev/null
+++ b/effects/jinni/jinni.kcfg
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+    http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-Jinni">
+        <entry name="Duration" type="UInt">
+            <default>600</default>
+            <min>1</min>
+        </entry>
+        <entry name="ShapeTransformTime" type="Double">
+            <default>0.4</default>
+            <min>0.001</min>
+        </entry>
+        <entry name="GridResolution" type="UInt">
+            <default>100</default>
+            <min>1</min>
+        </entry>
+    </group>
+</kcfg>
diff --git a/effects/jinni/jinni_config.cpp b/effects/jinni/jinni_config.cpp
new file mode 100644
index 000000000..3074a943a
--- /dev/null
+++ b/effects/jinni/jinni_config.cpp
@@ -0,0 +1,44 @@
+#include "jinni_config.h"
+// KConfigSkeleton
+#include "jinniconfig.h"
+#include <config-kwin.h>
+
+#include <kwineffects_interface.h>
+
+#include <KAboutData>
+#include <KPluginFactory>
+
+K_PLUGIN_FACTORY_WITH_JSON(JinniEffectConfigFactory,
+                           "jinni_config.json",
+                           registerPlugin<KWin::JinniEffectConfig>();)
+
+namespace KWin
+{
+
+JinniEffectConfig::JinniEffectConfig(QWidget *parent, const QVariantList &args)
+    : KCModule(KAboutData::pluginData(QStringLiteral("jinni")), parent, args)
+{
+    mUi.setupUi(this);
+    JinniConfig::instance(KWIN_CONFIG);
+    addConfig(JinniConfig::self(), this);
+
+    load();
+}
+
+JinniEffectConfig::~JinniEffectConfig()
+{
+}
+
+void JinniEffectConfig::save()
+{
+    KCModule::save();
+
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("jinni"));
+}
+
+} // namespace KWin
+
+#include "jinni_config.moc"
diff --git a/effects/jinni/jinni_config.desktop b/effects/jinni/jinni_config.desktop
new file mode 100644
index 000000000..13c6f15ec
--- /dev/null
+++ b/effects/jinni/jinni_config.desktop
@@ -0,0 +1,8 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_jinni_config
+X-KDE-ParentComponents=jinni
+
+Name=Jinni
\ No newline at end of file
diff --git a/effects/jinni/jinni_config.h b/effects/jinni/jinni_config.h
new file mode 100644
index 000000000..c00458984
--- /dev/null
+++ b/effects/jinni/jinni_config.h
@@ -0,0 +1,26 @@
+#ifndef JINNI_CONFIG_H
+#define JINNI_CONFIG_H
+
+#include <KCModule>
+#include "ui_jinni_config.h"
+
+namespace KWin
+{
+
+class JinniEffectConfig : public KCModule
+{
+    Q_OBJECT
+
+public:
+    explicit JinniEffectConfig(QWidget *parent = nullptr,const QVariantList& args = QVariantList());
+    ~JinniEffectConfig();
+
+    void save();
+
+private:
+    ::Ui::JinniEffectConfig mUi;
+};
+
+} // namespace KWin
+
+#endif
diff --git a/effects/jinni/jinni_config.ui b/effects/jinni/jinni_config.ui
new file mode 100644
index 000000000..a67f1b8ee
--- /dev/null
+++ b/effects/jinni/jinni_config.ui
@@ -0,0 +1,139 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>JinniEffectConfig</class>
+ <widget class="QWidget" name="JinniEffectConfig">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>169</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_2">
+   <item>
+    <layout class="QHBoxLayout" name="layout_Duration">
+     <item>
+      <widget class="QLabel" name="label_Duration">
+       <property name="maximumSize">
+        <size>
+         <width>120</width>
+         <height>16777215</height>
+        </size>
+       </property>
+       <property name="text">
+        <string>D&amp;uration:</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+       </property>
+       <property name="buddy">
+        <cstring>kcfg_Duration</cstring>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QSpinBox" name="kcfg_Duration">
+       <property name="suffix">
+        <string> milliseconds</string>
+       </property>
+       <property name="maximum">
+        <number>9999</number>
+       </property>
+       <property name="singleStep">
+        <number>5</number>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="layout_ShapeTransformTime">
+     <item>
+      <widget class="QLabel" name="label_ShapeTransformTime">
+       <property name="maximumSize">
+        <size>
+         <width>120</width>
+         <height>16777215</height>
+        </size>
+       </property>
+       <property name="text">
+        <string>Shape &amp;transform time:</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+       </property>
+       <property name="buddy">
+        <cstring>kcfg_ShapeTransformTime</cstring>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QDoubleSpinBox" name="kcfg_ShapeTransformTime">
+       <property name="maximum">
+        <double>1.000000000000000</double>
+       </property>
+       <property name="singleStep">
+        <double>0.050000000000000</double>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="layout_GridResolution">
+     <item>
+      <widget class="QLabel" name="label_GridResolution">
+       <property name="maximumSize">
+        <size>
+         <width>120</width>
+         <height>16777215</height>
+        </size>
+       </property>
+       <property name="text">
+        <string>&amp;Grid resolution:</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+       </property>
+       <property name="buddy">
+        <cstring>kcfg_GridResolution</cstring>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QSpinBox" name="kcfg_GridResolution">
+       <property name="minimum">
+        <number>1</number>
+       </property>
+       <property name="maximum">
+        <number>1000</number>
+       </property>
+       <property name="singleStep">
+        <number>5</number>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>40</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/effects/jinni/jinniconfig.kcfgc b/effects/jinni/jinniconfig.kcfgc
new file mode 100644
index 000000000..05c0f5c58
--- /dev/null
+++ b/effects/jinni/jinniconfig.kcfgc
@@ -0,0 +1,5 @@
+File=jinni.kcfg
+ClassName=JinniConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
diff --git a/effects/jinni/timeline.h b/effects/jinni/timeline.h
new file mode 100644
index 000000000..6d155538f
--- /dev/null
+++ b/effects/jinni/timeline.h
@@ -0,0 +1,118 @@
+#ifndef JINNI_TIMELINE_H
+#define JINNI_TIMELINE_H
+
+#include <QEasingCurve>
+
+class Timeline
+{
+public:
+    enum Direction {
+        Forward,
+        Backward
+    };
+
+public:
+    explicit Timeline(int duration = 1000, Direction direction = Forward)
+        : m_duration(duration)
+        , m_direction(direction)
+        , m_elapsed(0)
+        , m_finished(false) {}
+    virtual ~Timeline() {}
+
+    float progress() const {
+        Q_ASSERT(m_duration > 0);
+        auto t = static_cast<float>(m_elapsed) / m_duration;
+        if (m_direction == Backward) {
+            t = 1 - t;
+        }
+        return m_easingCurve.valueForProgress(t);
+    }
+
+    float rprogress() const {
+        Q_ASSERT(m_duration > 0);
+        auto t = static_cast<float>(m_elapsed) / m_duration;
+        if (m_direction == Forward) {
+            t = 1 - t;
+        }
+        return m_easingCurve.valueForProgress(t);
+    }
+
+    void update(int delta) {
+        Q_ASSERT(delta >= 0);
+        if (m_finished) {
+            return;
+        }
+        m_elapsed += delta;
+        if (m_elapsed >= m_duration) {
+            m_finished = true;
+            m_elapsed = m_duration;
+        }
+    }
+
+    int elapsed() const {
+        return m_elapsed;
+    }
+
+    void setElapsed(int elapsed) {
+        reset();
+        update(elapsed);
+    }
+
+    int duration() const {
+        return m_duration;
+    }
+
+    void setDuration(int duration) {
+        Q_ASSERT(duration > 0);
+        m_duration = duration;
+    }
+
+    Direction direction() const {
+        return m_direction;
+    }
+
+    void setDirection(Direction direction) {
+        if (m_direction == direction) {
+            return;
+        }
+        if (m_elapsed > 0) {
+            m_elapsed = m_duration - m_elapsed;
+        }
+        m_direction = direction;
+    }
+
+    void toggleDirection() {
+        setDirection(m_direction == Forward ? Backward : Forward);
+    }
+
+    QEasingCurve easingCurve() const {
+        return m_easingCurve;
+    }
+
+    void setEasingCurve(const QEasingCurve &easingCurve) {
+        m_easingCurve = easingCurve;
+    }
+
+    void setEasingCurve(QEasingCurve::Type type) {
+        m_easingCurve.setType(type);
+    }
+
+    bool done() const {
+        return m_finished;
+    }
+
+    void reset() {
+        m_elapsed = 0;
+        m_finished = false;
+    }
+
+private:
+    int m_duration;
+    Direction m_direction;
+    QEasingCurve m_easingCurve;
+
+    int m_elapsed;
+    bool m_finished;
+};
+
+#endif
\ No newline at end of file
-- 
2.14.1

